from API.Vzense_api_560 import *
import open3d as o3d
from math import *
import matplotlib.pyplot as plt

camera = VzenseTofCam()
filename = "save/point.txt"
filename_tf = "save/point_tf.txt"
rx,ry,rz = -2.559,.008,1.692 #rad
d = np.array([[-275.526],[-162.136],[868.773]]) #mm

new = False
if new:
    camera.init()
    camera.set_data_mode(DataMode.Depth_RGB)
    camera.set_mapper(Sensor.Depth,True)
    camera.set_depth_range(Range.Mid)
    camera.set_depth_distortion_correction(True)
    camera.set_depth_frame(Range.Mid)
    camera.set_compute_depth_correction(True)
    camera.set_threshold(90)
    frameready = camera.read_frame()

    if frameready and frameready.depth:      
        frame = camera.get_frame(Frame.Depth)
        pointlist = camera.convert_to_world_vector(frame)
        filename = "save/point.txt"

        fw = open(filename,"w")

        for i in range(frame.width*frame.height):
            if pointlist[i].z!=0 and pointlist[i].z!=65535 and pointlist[i].z < 1500:
                fw.write("{0} {1} {2}\n".format(pointlist[i].x,pointlist[i].y,pointlist[i].z))

        fw.close()
        print("Successfully saved")
    camera.stop_stream() 
    camera.close() 

    cX,sX,cY,sY,cZ,sZ = float(cos(rx)),float(sin(rx)),float(cos(ry)),float(sin(ry)),float(cos(rz)),float(sin(rz))

    rX = np.array([[1,0,0],[0,cX,-sX],[0,sX,cX]])
    rY = np.array([[cY,0,sY],[0,1,0],[-sY,0,cY]])
    rZ = np.array([[cZ,-sZ,0],[sZ,cZ,0],[0,0,1]])

    r_rot = np.matmul(rZ,np.matmul(rY,rX))#.transpose()

    with open(filename,"r") as fr:
        get_all = fr.readlines()
        fr.close()

    with open(filename_tf,"w") as fw:
        for line in get_all:
            st = line.strip("\n").split(" ")
            f = np.array([[float(st[0])],[float(st[1])],[float(st[2])]])
            tf = np.matmul(r_rot,f) + d
            tfl = tf.flatten()
            fw.write("{0} {1} {2}\n".format(tfl[0],tfl[1],tfl[2]))

cloud = o3d.io.read_point_cloud(filename_tf,format='xyz')
vccloud = cloud.voxel_down_sample(voxel_size=10)
mesh_frame = o3d.geometry.TriangleMesh.create_coordinate_frame(
    size=100, origin=[0,0,0])

#cl, ind = cloud.remove_statistical_outlier(nb_neighbors=20,std_ratio=2.0)
#cloud_fil = cl.select_by_index(ind)
hull,_ = cloud.compute_convex_hull()
hull_ls = o3d.geometry.LineSet.create_from_triangle_mesh(hull)
hull_ls.paint_uniform_color((1, 0, 0))
box = cloud.get_oriented_bounding_box()
print(np.asarray(box.get_box_points()))

mx,my,mz,lx,ly,lz = 0,0,0,0,0,0
sca = 25
for point in np.asarray(box.get_box_points()):
    x,y,z = point[0],point[1],point[2]
    if abs(x) >= abs(mx):
        mx = (abs(x) + sca)*x/abs(x)
    else:
        lx = (abs(x) + sca)*x/abs(x)
    if abs(y) >= abs(my):
        my = (abs(y) + sca)*y/abs(y)
    else:
        ly = (abs(y) + sca)*y/abs(y)
    if abs(z) >= abs(mz):
        mz = z
    else:
        lz = z
beeg = np.array([[mx,my,mz],[mx,ly,mz],[lx,ly,mz],[lx,my,mz],[mx,my,lz],[mx,ly,lz],[lx,ly,lz],[lx,my,lz]])
#print(beeg)
lines = [[0, 1], [1, 2], [2, 3], [0, 3],[4, 5], [5, 6], [6, 7], [4, 7],[0, 4], [1, 5], [2, 6], [3, 7]]

# Use the same color for all lines
colors = [[1, 0, 0] for _ in range(len(lines))]

line_set = o3d.geometry.LineSet()
line_set.points = o3d.utility.Vector3dVector(beeg)
line_set.lines = o3d.utility.Vector2iVector(lines)
line_set.colors = o3d.utility.Vector3dVector(colors)

o3d.visualization.draw_geometries([mesh_frame,line_set,hull_ls,cloud])


